---
description: Framework for planning and implementing development tasks
globs:
alwaysApply: false
---
# Development Workflow Framework

> **Note:** This file consolidates the planning guidelines previously contained in plan.mdc with the overall development workflow framework. The planning process is now fully integrated into this single comprehensive workflow document.

- **Related Rules:**
  - [knowledge-graph.mdc](mdc:.cursor/rules/knowledge-graph.mdc) (requires) - Development context
  - [mcp-tool-usage.mdc](mdc:.cursor/rules/mcp-tool-usage.mdc) (requires) - Development tools
  - [content-context.mdc](mdc:.cursor/rules/content-context.mdc) (requires) - Development timeline
  - [error-management.mdc](mdc:.cursor/rules/error-management.mdc) (requires) - Error handling
  - [implement.mdc](mdc:.cursor/rules/implement.mdc) (extended by) - Detailed implementation guidelines

## Planning Phase

### 1. Context Analysis
- **Understand requirements thoroughly**
  - Identify core functionality needs
  - Clarify constraints and limitations
  - Document dependencies
  - Reference relevant knowledge

### 2. Requirements Processing
- **Use Sequential Thinking for decomposition**
  - Break complex problems into manageable parts
  - Identify key components and interactions
  - Prioritize development tasks
  - Create clear success criteria

### 3. Detailed Planning Process

#### Understanding Requirements
<CLARIFICATION>
- Always ask for clarifications and follow-ups
- Identify underspecified requirements and ask for detailed information
- Fully understand all aspects of the problem and gather details to make it precise and clear
- Ask about all hypotheses and assumptions needed - remove ambiguities and uncertainties
- Suggest solutions that might not be apparent (anticipate needs)
- Only proceed to solution formulation after achieving complete clarity and confidence
</CLARIFICATION>

#### Formulating Solutions
<STEP BY STEP REASONING>
<DECOMPOSE>
- Create a meta architecture plan for the solution
- Break down the problem into key concepts and smaller sub-problems
</DECOMPOSE>
- Think about all possible ways to solve the problem
- Set up evaluation criteria and trade-offs to assess solution merit
- Find the optimal solution and identify what makes it optimal

<WEB USE>
- Use web research when needed via appropriate MCP tools
- Particularly useful for technical specifications, standards, or best practices
</WEB USE>

<MULTI ATTEMPTS>
- Reason rigorously about solution optimality
- Question every assumption and inference with comprehensive reasoning
- Consider better solutions by combining the strongest aspects of different approaches
- Iterate through the process, refining and integrating solutions until a strong option emerges
- Use web research when needed for technical validation
</MULTI ATTEMPTS>
</STEP BY STEP REASONING>

#### Solution Validation
<REASONING PRESENTATION>
- Provide detailed plans with comprehensive specifics
- Break down the solution step-by-step with clarity on each component
- Reason out optimality compared to other promising solutions
- Explicitly state all assumptions, choices, and decisions
- Clearly explain trade-offs between different solutions
- Restate the original query when appropriate to confirm understanding
</REASONING PRESENTATION>
- Before implementation, thoroughly validate the solution plan produced

### 4. Solution Design
- **Generate solution alternatives**
  - Evaluate potential approaches
  - Consider trade-offs
  - Select optimal path
  - Document decision rationale

## Implementation Phase

### 1. Development Context
- **Establish implementation framework**
  - Reference planning outcomes
  - Identify affected codebase areas
  - Document dependencies
  - Select appropriate tools

### 2. Code Management
- **Follow programming principles**
  - Maintain algorithm efficiency
  - Ensure code modularity
  - Preserve working components
  - Apply appropriate design patterns

### 3. Quality Control
- **Validate implementation**
  - Run automated tests
  - Perform code reviews
  - Verify documentation
  - Validate against plan

## Tool Integration

### 1. Development Tools
- **Leverage appropriate code tools**
  - Analysis utilities
  - Testing frameworks
  - Documentation generators
  - Version control

### 2. Knowledge Tools
- **Apply knowledge tools**
  - Sequential Thinking
  - Web search
  - Knowledge Graph
  - Content context

## Validation Protocol

### 1. Plan Validation
- **Verify plan completeness**
  - Requirements coverage
  - Constraint compliance
  - Resource availability
  - Risk assessment

### 2. Implementation Validation
- **Ensure implementation quality**
  - Code quality
  - Test coverage
  - Documentation completeness
  - Performance metrics

## <PLANNING>
### UNDERSTANDING REQUIREMENTS
<CLARIFICATION>
- Always ask for clarifications and follow-ups
- Identify underspecified requirements
- Fully understand all aspects of the problem
- Remove ambiguities and uncertainties
- Suggest solutions that might not be apparent
</CLARIFICATION>

### FORMULATING SOLUTIONS
<STEP BY STEP REASONING>
- Have a meta architecture plan
- Break down problems into key concepts
- Think of all possible solutions
- Evaluate approaches against criteria
- Find optimal solution with clear reasoning
</STEP BY STEP REASONING>

### SOLUTION VALIDATION
<REASONING PRESENTATION>
- Provide detailed plans
- Break down solutions step-by-step
- Reason out optimality vs alternatives
- State all assumptions explicitly
- Explain trade-offs clearly
</REASONING PRESENTATION>
</PLANNING>

## <IMPLEMENTATION>
### <PROGRAMMING PRINCIPLES>
- **algorithm_efficiency**: Use efficient algorithms and data structures
- **modularity**: Break complex logic into smaller atomic parts
- **file_management**: Break long files into manageable pieces
- **import_statements**: Prefer importing from other files over modification
- **file_organization**: Organize files logically
- **reuse**: Prefer to reuse existing code
- **code_preservation**: Preserve working components
- **systematic_sequence**: Complete one step before starting another
- **design_patterns**: Apply appropriate patterns for maintainability
- **proactive_testing**: Include proper tests with functionality
</PROGRAMMING PRINCIPLES>

### <SYSTEMATIC CODE PROTOCOL>
1. **ANALYZE CODE**
   - Identify affected components
   - Document dependencies
   - Analyze flow from entry point to execution
   - Track data and logic flow

2. **PLAN CODE**
   - Outline detailed plan with dependencies
   - Explain all changes and impacts
   - Document tradeoffs
   - Provide structured proposal

3. **MAKE CHANGES**
   - Document current state
   - Plan single logical change at a time
   - Simulate interactions for validation
   - Implement verified changes

4. **TEST THOROUGHLY**
   - Create unit tests for new functionality
   - Verify existing behavior remains correct
   - Document test coverage and results
</SYSTEMATIC CODE PROTOCOL>

### <TESTING>
- **Create comprehensive test plans**
  - Cover normal cases and edge cases
  - Verify against requirements
  - Test integration points
  - Check error handling

- **Implement tests for all critical functionality**
  - Unit tests for isolated components
  - Integration tests for interactions
  - Performance tests for critical paths
  - Document all test scenarios
</TESTING>
</IMPLEMENTATION>

## Documentation Requirements

### 1. Planning Documentation
- Requirements analysis
- Solution design
- Decision rationale
- Risk mitigation

### 2. Implementation Documentation
- Code changes
- Test cases
- Configuration updates
- Deployment notes

## Success Patterns

### 1. Planning Patterns
- Clear requirements
- Thorough analysis
- Documented decisions
- Validated approach

### 2. Implementation Patterns
- Clean code
- Comprehensive tests
- Updated documentation
- Efficient deployment
